{
    "summary": "This code creates timestep embeddings and diffusion schedules for DDIM or DDPG methods, enabling efficient deep learning models. It also generates betas values to prevent singularities in the diffusion process.",
    "details": [
        {
            "comment": "This function generates timestep embeddings for use in diffusion models. It supports sinusoidal embeddings (default) or repeating embeddings based on input timesteps. The sinusoidal embeddings are created using sine and cosine functions, while the repeat option simply replicates the input timesteps 'd' times.",
            "location": "\"/media/root/Prima/works/DynamiCrafter/docs/src/lvdm/models/utils_diffusion.py\":0-26",
            "content": "import math\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom einops import repeat\ndef timestep_embedding(timesteps, dim, max_period=10000, repeat_only=False):\n    \"\"\"\n    Create sinusoidal timestep embeddings.\n    :param timesteps: a 1-D Tensor of N indices, one per batch element.\n                      These may be fractional.\n    :param dim: the dimension of the output.\n    :param max_period: controls the minimum frequency of the embeddings.\n    :return: an [N x dim] Tensor of positional embeddings.\n    \"\"\"\n    if not repeat_only:\n        half = dim // 2\n        freqs = torch.exp(\n            -math.log(max_period) * torch.arange(start=0, end=half, dtype=torch.float32) / half\n        ).to(device=timesteps.device)\n        args = timesteps[:, None].float() * freqs[None]\n        embedding = torch.cat([torch.cos(args), torch.sin(args)], dim=-1)\n        if dim % 2:\n            embedding = torch.cat([embedding, torch.zeros_like(embedding[:, :1])], dim=-1)\n    else:\n        embedding = repeat(timesteps, 'b -> b d', d=dim)"
        },
        {
            "comment": "This code defines a function `make_beta_schedule` that generates a schedule of beta values for diffusion models. The function takes in the scheduling method (linear, cosine, sqrt_linear, or sqrt), number of timesteps, and optional parameters for linear and cosine schedules. It returns an array of beta values representing the schedule.\n\nThe code also includes a `make_ddim_timesteps` function which takes in the discretization method (either DDIM or DDPG), the number of DDIM timesteps, and the number of DDPM timesteps. It generates the corresponding timesteps for the chosen method.\n\nThese functions are used to create a diffusion model schedule and generate timesteps for the model, which can be utilized in various deep learning tasks.",
            "location": "\"/media/root/Prima/works/DynamiCrafter/docs/src/lvdm/models/utils_diffusion.py\":27-55",
            "content": "    return embedding\ndef make_beta_schedule(schedule, n_timestep, linear_start=1e-4, linear_end=2e-2, cosine_s=8e-3):\n    if schedule == \"linear\":\n        betas = (\n                torch.linspace(linear_start ** 0.5, linear_end ** 0.5, n_timestep, dtype=torch.float64) ** 2\n        )\n    elif schedule == \"cosine\":\n        timesteps = (\n                torch.arange(n_timestep + 1, dtype=torch.float64) / n_timestep + cosine_s\n        )\n        alphas = timesteps / (1 + cosine_s) * np.pi / 2\n        alphas = torch.cos(alphas).pow(2)\n        alphas = alphas / alphas[0]\n        betas = 1 - alphas[1:] / alphas[:-1]\n        betas = np.clip(betas, a_min=0, a_max=0.999)\n    elif schedule == \"sqrt_linear\":\n        betas = torch.linspace(linear_start, linear_end, n_timestep, dtype=torch.float64)\n    elif schedule == \"sqrt\":\n        betas = torch.linspace(linear_start, linear_end, n_timestep, dtype=torch.float64) ** 0.5\n    else:\n        raise ValueError(f\"schedule '{schedule}' unknown.\")\n    return betas.numpy()\ndef make_ddim_timesteps(ddim_discr_method, num_ddim_timesteps, num_ddpm_timesteps, verbose=True):"
        },
        {
            "comment": "The code determines the timesteps for DDIM sampling, based on the specified discretization method. If the method is 'uniform', it divides the number of DDPM timesteps by the number of DDIM timesteps to create a uniformly spaced array of timesteps. If the method is 'quad', it creates evenly spaced quadratic roots from 0 to the square root of 0.8 times the product of the number of DDPM and DDIM timesteps, then squares the results to get the final timesteps. The code also checks for unimplemented methods and raises a NotImplementedError if encountered.",
            "location": "\"/media/root/Prima/works/DynamiCrafter/docs/src/lvdm/models/utils_diffusion.py\":56-76",
            "content": "    if ddim_discr_method == 'uniform':\n        c = num_ddpm_timesteps // num_ddim_timesteps\n        ddim_timesteps = np.asarray(list(range(0, num_ddpm_timesteps, c)))\n    elif ddim_discr_method == 'quad':\n        ddim_timesteps = ((np.linspace(0, np.sqrt(num_ddpm_timesteps * .8), num_ddim_timesteps)) ** 2).astype(int)\n    else:\n        raise NotImplementedError(f'There is no ddim discretization method called \"{ddim_discr_method}\"')\n    # assert ddim_timesteps.shape[0] == num_ddim_timesteps\n    # add one to get the final alpha values right (the ones from first scale to data during sampling)\n    steps_out = ddim_timesteps + 1\n    if verbose:\n        print(f'Selected timesteps for ddim sampler: {steps_out}')\n    return steps_out\ndef make_ddim_sampling_parameters(alphacums, ddim_timesteps, eta, verbose=True):\n    # select alphas for computing the variance schedule\n    # print(f'ddim_timesteps={ddim_timesteps}, len_alphacums={len(alphacums)}')\n    alphas = alphacums[ddim_timesteps]\n    alphas_prev = np.asarray([alphacums[0]] + alphacums[ddim_timesteps[:-1]].tolist())"
        },
        {
            "comment": "This function calculates sigmas for ddim sampler using a formula from the given reference. It also prints selected alphas and resulting sigma_t schedule for ddim sampler if verbose is True. The betas_for_alpha_bar function creates a beta schedule by discretizing the alpha_t_bar function, which defines the cumulative product of (1-beta) over time from t = [0,1].",
            "location": "\"/media/root/Prima/works/DynamiCrafter/docs/src/lvdm/models/utils_diffusion.py\":78-95",
            "content": "    # according the the formula provided in https://arxiv.org/abs/2010.02502\n    sigmas = eta * np.sqrt((1 - alphas_prev) / (1 - alphas) * (1 - alphas / alphas_prev))\n    if verbose:\n        print(f'Selected alphas for ddim sampler: a_t: {alphas}; a_(t-1): {alphas_prev}')\n        print(f'For the chosen value of eta, which is {eta}, '\n              f'this results in the following sigma_t schedule for ddim sampler {sigmas}')\n    return sigmas, alphas, alphas_prev\ndef betas_for_alpha_bar(num_diffusion_timesteps, alpha_bar, max_beta=0.999):\n    \"\"\"\n    Create a beta schedule that discretizes the given alpha_t_bar function,\n    which defines the cumulative product of (1-beta) over time from t = [0,1].\n    :param num_diffusion_timesteps: the number of betas to produce.\n    :param alpha_bar: a lambda that takes an argument t from 0 to 1 and\n                      produces the cumulative product of (1-beta) up to that\n                      part of the diffusion process.\n    :param max_beta: the maximum beta to use; use values lower than 1 to"
        },
        {
            "comment": "This function generates betas values for the diffusion process, preventing singularities. It iterates through timesteps, calculates t1 and t2 values, then appends the minimum value of (1 - alpha_bar(t2) / alpha_bar(t1)) and max_beta to the list of betas. Finally, it returns a numpy array of these betas values.",
            "location": "\"/media/root/Prima/works/DynamiCrafter/docs/src/lvdm/models/utils_diffusion.py\":96-103",
            "content": "                     prevent singularities.\n    \"\"\"\n    betas = []\n    for i in range(num_diffusion_timesteps):\n        t1 = i / num_diffusion_timesteps\n        t2 = (i + 1) / num_diffusion_timesteps\n        betas.append(min(1 - alpha_bar(t2) / alpha_bar(t1), max_beta))\n    return np.array(betas)"
        }
    ]
}